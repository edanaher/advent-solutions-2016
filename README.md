Advent of Code Solutions 2016
=============================

25 languages in 25 days
-----------------------

In [2015](https://github.com/edanaher/advent-solutions), I found out about [Advent of Code](http://adventofcode.com) early, and happened to be on the west coast.  In the final rankings, I got 28th, which I'm pretty happy with, especially given that I was back on the east coast for the last week or so and didn't want to stay up until midnight.

This year, I got a late start and didn't want to stay up until midnight to compete on time, so instead decided to do a different language each day.  There's also a chance I'll go ahead and do 25 languages for *each* day (at least the easy ones); specific rules TBD.

Rules
-----
While the goal was to have fun, I followed the following approximate rules:

- Each language can only be used once.
- Even though I'm starting late, no looking ahead.  Combined with the above, this mean's I'll try to use interesting languages early, and save the easier ones for harder problems.
- Where possible, prefer "interesting" languages.
- Each solution must use as little scaffolding as possible (e.g., not using sed to massage the input into a more useful form unless absolutely necessary); however, for simplicity, `make [day number][a or b]` will run that day, assuming an appropriate environment.
- Each solution should read from stdin.

Languages
---------

### "Interesting"
- ARM assembly
- ~~awk~~ (day 1)
- bash
- bc
- befunge
- brainf*ck
- cpp (C preprocessor)
- csh
- C++ templates
- dc
- Intercal
- J
- jq
- nix
- prolog
- sed
- shakespeare
- SQL
- unlambda
- x86 assembly

### "Boring"
- C/C++
- CLISP
- Clojure
- Erlang
- Forth
- Haskell
- Java
- Javascript
- Nimrod
- Ocaml
- perl
- PHP
- python
- ruby
- Rust
- Scala
- Scheme
- Smalltalk
- SML
- tcl





Tense
-----
Yeah, I haven't done this yet.  But I almost certainly will, and having written the above in the past tense means it'll be accurate after I finish, which will be longer than when it's incomplete ;)

